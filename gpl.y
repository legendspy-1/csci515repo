%code requires{
  #include <string>
  class Expression;
  class Variable;
  class Statement;
  #ifndef P1
    #include "types_and_ops.h"  //include in all projects except the first
  #endif
  #ifdef GRAPHICS
    #include "Window.h"
  #endif}

// bison syntax to indicate the beginning of a C/C++ code section
%{
#include "scope_man.h"
#include "Constant.h"
Scope_manager sm;
extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include <iostream>

// bison syntax indicating the end of a C/C++ code section
%} 


// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 int            union_int;
 std::string*   union_string;  // MUST be a pointer to a string
 double         union_double;
 gamelang::Type union_gpl_type;
 const Expression* union_expression_ptr;
 Variable* union_variable_ptr;
}

%destructor { delete $$; } <union_string>

// tokens declared here

%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token T_FORWARD             "forward"
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_string> T_EXIT            "exit"  
%token <union_string> T_PRINT           "print"  
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"

%token <union_int> T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token <union_string> T_ID            	 "identifier"

 // special token that does not match any production 
 // used for characters that are not part of the language 
%token T_ERROR               "error"

%left T_OR 
%left T_AND
%left T_EQUAL 
%left T_NOT_EQUAL
%left T_LESS 
left T_GREATER 
%left T_LESS_EQUAL 
%left T_GREATER_EQUAL
%left T_PLUS 
%left T_MINUS
%left T_MULTIPLY 
%left T_DIVIDE 
%left T_MOD
%right T_NOT 
%right NEGATION
%nonassoc IF_NO_ELSE
%nonassoc T_ELSE
%nonassoc T_NEAR 
%nonassoc T_TOUCHES
%type <union_gpl_type> simple_type
%type <union_expression_ptr> primary_expression
%type <union_expression_ptr> expression
%type <union_expression_ptr> optional_initializer
%type <union_variable_ptr> variable


%%

//---------------------------------------------------------------------
program:
  declaration_list block_list


//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | %empty


//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC


//---------------------------------------------------------------------
variable_declaration:
    simple_type T_ID optional_initializer {
        if (!$2) { YYERROR; }
        if(sm.defined_in_current_scope(*$2)) {
            gamelang::error(gamelang::PREVIOUSLY_DECLARED_VARIABLE,*$2);
            delete $2;
            break;
        }

        Symbol* symbol = nullptr;
        try {
            if ($1 == gamelang::INT) {
                int val = 0;
                if ($3 != nullptr) {
                    if (auto var_expr = dynamic_cast<const Variable*>($3)) {
                        Symbol* init_sym = sm.lookup(var_expr->get_symbol_name());
                        if (init_sym && init_sym->get_count() > 1
                            && var_expr->is_whole_array_reference())
                        {
                            gamelang::error(gamelang::VARIABLE_IS_AN_ARRAY, init_sym->get_name());
                            delete $2; delete $3; break;
                        }
                    }

                    std::unique_ptr<const Constant> constant($3->evaluate());
                    if (constant == nullptr) {
                        delete $2;
                        delete $3;
                        break;
                    }

                    gamelang::Type actual_type = constant->type();
                    if (actual_type != gamelang::INT) {
                        throw actual_type;
                    }
                    val = constant->as_int();
                    delete $3;
                }
                symbol = new Symbol(*$2, new int(val));
            }
            else if ($1 == gamelang::DOUBLE) {
                double val = 0.0;
                if ($3 != nullptr) {
                    if (auto var_expr = dynamic_cast<const Variable*>($3)) {
                        Symbol* init_sym = sm.lookup(var_expr->get_symbol_name());
                        if (init_sym && init_sym->get_count() > 1
                            && var_expr->is_whole_array_reference())
                        {
                            gamelang::error(gamelang::VARIABLE_IS_AN_ARRAY, init_sym->get_name());
                            delete $2; delete $3; break;
                        }
                    }

                    std::unique_ptr<const Constant> constant($3->evaluate());
                    if (constant == nullptr) {
                        delete $2;
                        delete $3;
                        break;
                    }

                    gamelang::Type actual_type = constant->type();
                    if (actual_type != gamelang::DOUBLE &&
                        actual_type != gamelang::INT) {
                        throw actual_type;
                    }
                    val = constant->as_double();
                    delete $3;
                }
                symbol = new Symbol(*$2, new double(val));
            }
            else if ($1 == gamelang::STRING) {
                std::string val = "";
                if ($3 != nullptr) {
                    if (auto var_expr = dynamic_cast<const Variable*>($3)) {
                        Symbol* init_sym = sm.lookup(var_expr->get_symbol_name());
                        if (init_sym && init_sym->get_count() > 1
                            && var_expr->is_whole_array_reference())
                        {
                            gamelang::error(gamelang::VARIABLE_IS_AN_ARRAY, init_sym->get_name());
                            delete $2; delete $3; break;
                        }
                    }

                    std::unique_ptr<const Constant> constant($3->evaluate());
                    if (constant == nullptr) {
                        delete $2;
                        delete $3;
                        break;
                    }

                    val = constant->as_string();
                    delete $3;
                }
                symbol = new Symbol(*$2, new std::string(val));
            }
        }
        catch (gamelang::Type actual_type) {
            std::string expected = gamelang::to_string($1);
            std::string actual = gamelang::to_string(actual_type);
            gamelang::error(gamelang::INVALID_TYPE_FOR_INITIAL_VALUE, actual, *$2, expected);
            delete $2;
            if ($3 != nullptr) delete $3;
            break;
        }

        sm.add_to_current_scope(symbol);
        delete $2;
    }
    | simple_type T_ID T_LBRACKET expression T_RBRACKET {
        if (sm.defined_in_current_scope(*$2)) {
            gamelang::error(gamelang::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;
            delete $4;
            break;
        }

        std::unique_ptr<const Constant> size_constant($4->evaluate());
        gamelang::Type size_type = size_constant ? size_constant->type() : gamelang::NO_TYPE;

        if (size_constant == nullptr) {
            delete $2;
            delete $4;
            break;
        }
        if (size_type != gamelang::INT) {
            gamelang::error(gamelang::ARRAY_SIZE_MUST_BE_AN_INTEGER,
                            gamelang::to_string(size_type), *$2);
            delete $2;
            delete $4;
            break;
        }

        int size = size_constant->as_int();
        if (size < 1) {
            gamelang::error(gamelang::INVALID_ARRAY_SIZE, *$2, std::to_string(size));
            delete $2;
            delete $4;
            break;
        }

        Symbol* sym = nullptr;
        if ($1 == gamelang::INT) {
            int* arr = new int[size];
            for (int i = 0; i < size; i++) arr[i] = i;
            sym = new Symbol(*$2, arr, size);
        }
        else if ($1 == gamelang::DOUBLE) {
            double* arr = new double[size];
            for (int i = 0; i < size; i++) arr[i] = i + 0.5;
            sym = new Symbol(*$2, arr, size);
        }
        else if ($1 == gamelang::STRING) {
            std::string* arr = new std::string[size];
            for (int i = 0; i < size; i++) arr[i] = std::to_string(i);
            sym = new Symbol(*$2, arr, size);
        }
        sm.add_to_current_scope(sym);
        delete $2;
        delete $4;
    }
    ;

//---------------------------------------------------------------------
simple_type:
    T_INT      {$$=gamelang::INT;}
    | T_DOUBLE {$$=gamelang::DOUBLE;}
    | T_STRING {$$=gamelang::STRING;}


//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression { $$ = $2; }
    | %empty { $$ = nullptr; }


//---------------------------------------------------------------------
object_declaration:
    object_type T_ID parameter_list_or_empty
    | object_type T_ID T_LBRACKET expression T_RBRACKET


//---------------------------------------------------------------------
object_type:
    T_TRIANGLE
    | T_PIXMAP
    | T_CIRCLE
    | T_RECTANGLE
    | T_TEXTBOX


//---------------------------------------------------------------------
parameter_list_or_empty :
    T_LPAREN parameter_list T_RPAREN
    | T_LPAREN T_RPAREN
    | %empty


//---------------------------------------------------------------------
parameter_list :
    parameter_list T_COMMA parameter
    | parameter


//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression


//---------------------------------------------------------------------
block_list:
    block_list block
    | %empty


//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block


//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block


//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block


//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN


//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID
    | object_type


//---------------------------------------------------------------------
animation_block:
    animation_declaration statement_block


//---------------------------------------------------------------------
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN


//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block


//---------------------------------------------------------------------
keystroke:
    T_SPACE
    | T_UPARROW
    | T_DOWNARROW
    | T_LEFTARROW
    | T_RIGHTARROW
    | T_LEFTMOUSE_DOWN
    | T_MIDDLEMOUSE_DOWN
    | T_RIGHTMOUSE_DOWN
    | T_LEFTMOUSE_UP
    | T_MIDDLEMOUSE_UP
    | T_RIGHTMOUSE_UP
    | T_MOUSE_MOVE
    | T_MOUSE_DRAG
    | T_AKEY
    | T_SKEY
    | T_DKEY
    | T_FKEY
    | T_HKEY
    | T_JKEY
    | T_KKEY
    | T_LKEY
    | T_WKEY
    | T_ZKEY
    | T_F1


//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block
    | statement


//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE
    | T_LBRACE T_RBRACE



//---------------------------------------------------------------------
statement_list:
    statement_list statement
    | statement


//---------------------------------------------------------------------
statement:
    if_statement
    | for_statement
    | assign_statement T_SEMIC
    | print_statement T_SEMIC
    | exit_statement T_SEMIC


//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement %prec IF_NO_ELSE
  | T_IF T_LPAREN expression T_RPAREN statement T_ELSE statement;


//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements


//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN


//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN


//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement
    | %empty


//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression
    | variable T_PLUS_ASSIGN expression
    | variable T_MINUS_ASSIGN expression
    | variable T_PLUS_PLUS
    | variable T_MINUS_MINUS


//---------------------------------------------------------------------
variable:
    T_ID{
    $$ = new Variable(*$1); // simple variable
      delete $1;
    }
    | T_ID T_LBRACKET expression T_RBRACKET{
        $$ = new Variable(*$1, $3); // array access
        delete $1;
    }
    | T_ID T_PERIOD T_ID{
        $$ = new Variable(""); // placeholder, implemented later
        delete $1;
        delete $3;
    }
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID {
        $$ = new Variable("");
        delete $1;
        delete $3;
        delete $6;
    }


//---------------------------------------------------------------------
expression: primary_expression {$$=$1;}

expression:
    expression T_OR expression { $$=new Or($1, $3);}
    | expression T_AND expression { $$=new And($1, $3);}
    | expression T_LESS_EQUAL expression {$$=new LessThanOrEqual($1, $3);}
    | expression T_GREATER_EQUAL  expression {$$=new GreaterThanOrEqual($1, $3);}
    | expression T_LESS expression {$$=new LessThan($1, $3);}
    | expression T_GREATER  expression {$$=new GreaterThan($1, $3);}
    | expression T_EQUAL expression {$$=new Equal($1, $3);}
    | expression T_NOT_EQUAL expression {$$=new NotEqual($1, $3);}
    | expression T_PLUS expression  { $$=new Add($1, $3); }
    | expression T_MINUS expression {
        gamelang::Type left_type = $1->type();
        gamelang::Type right_type = $3->type();
        bool valid_left = (left_type == gamelang::INT || left_type == gamelang::DOUBLE);
        bool valid_right = (right_type == gamelang::INT || right_type == gamelang::DOUBLE);
        if (!valid_left)
            gamelang::error(gamelang::INVALID_LEFT_OPERAND_TYPE, "-");
        if (!valid_right)
            gamelang::error(gamelang::INVALID_RIGHT_OPERAND_TYPE, "-");
        if (valid_left && valid_right)
            $$ = new Subtract($1, $3);
        else {
            $$ = new Integer_constant(0);
            delete $1;
            delete $3;
        }
      }
    | expression T_MULTIPLY expression {
        gamelang::Type left_type = $1->type();
        gamelang::Type right_type = $3->type();
        bool valid_left = (left_type == gamelang::INT || left_type == gamelang::DOUBLE);
        bool valid_right = (right_type == gamelang::INT || right_type == gamelang::DOUBLE);
        if (!valid_left)
            gamelang::error(gamelang::INVALID_LEFT_OPERAND_TYPE, "*");
        if (!valid_right)
            gamelang::error(gamelang::INVALID_RIGHT_OPERAND_TYPE, "*");
        if (valid_left && valid_right)
            $$ = new Multiply($1, $3);
        else {
            $$ = new Integer_constant(0);
            delete $1;
            delete $3;
        }
    }
    | expression T_DIVIDE expression {
        gamelang::Type left_type = $1->type();
        gamelang::Type right_type = $3->type();
        bool valid_left = (left_type == gamelang::INT || left_type == gamelang::DOUBLE);
        bool valid_right = (right_type == gamelang::INT || right_type == gamelang::DOUBLE);
        if (!valid_left)
            gamelang::error(gamelang::INVALID_LEFT_OPERAND_TYPE, "/");
        if (!valid_right)
            gamelang::error(gamelang::INVALID_RIGHT_OPERAND_TYPE, "/");
        if (valid_left && valid_right)
            $$ = new Divide($1, $3);
        else {
            $$ = new Integer_constant(0);
            delete $1;
            delete $3;
        }
    }
    | expression T_MOD expression {
        gamelang::Type left_type = $1->type();
        gamelang::Type right_type = $3->type();
        bool valid_left = (left_type == gamelang::INT);
        bool valid_right = (right_type == gamelang::INT);
        if (!valid_left)
            gamelang::error(gamelang::INVALID_LEFT_OPERAND_TYPE, "%");
        if (!valid_right)
            gamelang::error(gamelang::INVALID_RIGHT_OPERAND_TYPE, "%");
        if (valid_left && valid_right)
            $$ = new Mod($1, $3);
        else {
            $$ = new Integer_constant(0);
            delete $1;
            delete $3;
        }
    }
    | T_MINUS  expression %prec NEGATION {
        gamelang::Type expr_type = $2->type();
        if (expr_type != gamelang::INT && expr_type != gamelang::DOUBLE) {
            gamelang::error(gamelang::INVALID_RIGHT_OPERAND_TYPE, "-");
            $$ = new Integer_constant(0);
            delete $2;
        } else {
            $$ = new Negation($2);
        }
    }
    | T_NOT  expression {$$=new Not($2);}
    | expression T_NEAR expression
    | expression T_TOUCHES expression


primary_expression:
    T_SIN T_LPAREN expression T_RPAREN {$$=new Sin($3);}
    | T_COS T_LPAREN expression T_RPAREN {$$=new Cos($3);}
    | T_TAN T_LPAREN expression T_RPAREN {$$=new Tan($3);}
    | T_ASIN T_LPAREN expression T_RPAREN {$$=new Asin($3);}
    | T_ACOS T_LPAREN expression T_RPAREN {$$=new Acos($3);}
    | T_ATAN T_LPAREN expression T_RPAREN {$$=new Atan($3);}
    | T_SQRT T_LPAREN expression T_RPAREN {$$=new Sqrt($3);}
    | T_ABS T_LPAREN expression T_RPAREN {$$=new Abs($3);}
    | T_FLOOR T_LPAREN expression T_RPAREN {$$=new Floor($3);}
    | T_RANDOM T_LPAREN expression T_RPAREN {$$=new Random($3);}


//---------------------------------------------------------------------
primary_expression:
    T_LPAREN expression T_RPAREN {$$= $2;}
    | variable {$$ = $1;}
    | T_INT_CONSTANT { $$=new Integer_constant($1); }
    | T_TRUE { $$=new Integer_constant(1); }
    | T_FALSE { $$=new Integer_constant(0); }
    | T_DOUBLE_CONSTANT { $$ = new Double_constant($1); }
    | T_STRING_CONSTANT { $$ = new String_constant(*$1); delete $1; }


%%
